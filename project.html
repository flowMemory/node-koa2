<!-- 
    服务端编程：
        * 项目启动 node app.js
        1. 确定项目架构，目录结构
        2. 基础的项目构成：
            1. 接口api
            2. 参数解析，校验，正确响应客户端
            3. 异常处理api
        
        3. 区分koa@/router 和 koa-router

        4. 中间件: koa2 面相中间件编程，每一个方法都是一个中间件（中间件声明后可以交给全局对象注册！）

        5. V2版本：
                使用 lin-validator 检验路由参数

                取参方式：
                    v.get("query.id")   url ?参数
                    v.get("path.id")    请求路径
                    v.get("body.id")    json 参数

    项目结构目录规划：
        1. api: 存放各个版本的接口，每个版本分为不同的文件夹
            1. v1 v2（ Version ）编写具体的接口文件
               路由自动注册

            2. modals：数据库操作模块

        
        2. core: 非业务代码，初始化，数据库连接等模块
            db.js: 数据库连接模块

        3. validators: 参数校验类
        4. middlewares: 全局异常捕获中间件
        5. config：项目的配置文件
        6. modals：数据库操作模块

        疑问：
            1. require() 导入的模块可以任意赋值？
                module.export = router
                const a = require('book.js')

            2. 引用lin-validator
                为什么有些地方还要throw new error

    数据库：
        数据库分类：
            关系型数据库：
                1. SQLserver  2. Oracle  3. mysql ...
            非关系型数据库
                1. MongoDb    2. Redis
        
        编程化创建数据表结构： ORM （虚拟对象数据库） 以操作对象的方式创建操作数据库
            1. Sequelize ：ORM框架
            2. 基本用法：
                1. 引入Sequelize 传入数据库配置( ip地址, 用户名, 密码... )
                2. 创建数据表，初始化数据字段

                对象型数据库的用法理念：
                    对于数据的操作：写入，查询等都是在业务代码中以对象的方式操作的

                3. 用法二，写入数据需要提前在model模块配置表字段
                   
                4. 这里的model user模块承担的业务划分是否合理，这里集中了初始化表字段，查询，常见数据等业务，是否需要重新划分业务模块


        关系型数据库常识：
            1. 主键的设置：用户的唯一性标识：不能重复，不能为空
                1. 随机性主键：查找速度慢
                2. 自增型主键：可破解难度低


        数据库编程经验：
            注册接口：
                1. 注册接口要保障主键的唯一性，在注册前需要查询库数据是否已存在
                2. 注册的核心数据要以密文的方式存储，比如密码...

                注册接口常规方式：
                    1. 注册信息提交
                    2. 校验路由参数的合法性
                    3. 校验读取数据库校验账号信息的唯一性
                    4. 对需要加密的字段进行存储加密，为账号分配主键id
                    5. 最后入口返回客户端成功的信息

                    * 在这个过程中如果发生异常也需要把异常抛出，定义明确的错误码，和错误信息

            加密库：
                bcrypt.js
        
        服务端接口：
            2. 登录接口
                登录接口常规方式：
                        登录的两种状态：
                            一首次登录，需要提供账号密码验证身份，返回token
                            二利用token做无痕登录，验证token的有效性，有效则直接登录，无效则重新拉起账号登录
                    1. 客户端登录提交登录信息和登录方式到服务接口
                    2. 验证路由参数的合法性
                    3. 向数据库查询账号，密码的有效性
                    4. 查询成功后需要根据用户的身份信息生成登录身份令牌（token）返回给客户端

                    * 在登录的过程中注意登录身份的有效性，token的时效，给客户端明确的返回信息

                登陆令牌：token
                访问令牌：Access token
                密保令牌：Security token
                会话令牌：Session token
                    1. 令牌含义：
                        在OAuth协议中，token是在输入了用户名和密码之后获取的，利用这个token你可以拥有查看或者操作相应的资源的权限。你有这些权限，是因为服务器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。
                        器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。
                    
                    2. 生成：
                        1. 用户登录后后端根据用户信息生成一个唯一的凭证，这个就是token值
                    
                    3. 使用：
                        客服端获取服务端的token后保存在本地中，作为用户已登录的依据，访问时验证token的有效性，从而无需用户重复登录
                        可以保存在用户的cookie localStorage

                    4. token的有效性：
                        资讯型网站用户数据不是太敏感，token可以较长。银行类，支付类网站token时效性较短

                    5. 唯一性：
                        当用户重新登录或者token已过时需要重新获取令牌

            3. 用户权限管理：
                权限的意义：
                    对登录的用户做开放权力的区分对待：超级管理员，管理员，会员，普通用户，游客等身份象征，不同的角色会开放不同的权限。
                    和接口的权限做对应关系
                做法1：
                    1. 利用token的scope对用户做权限分级
                    2. 在用户登录的的时候根据登录方式确定权限等级，在登录合法后为用户分配token。同时给token的scope分配权限
                    3. 在用户访问api时校验参数，校验api的权限等级，把参数中token.scope.auth等级和api所需要的auth等级做对比
                    4. 最后做出判断，用户的权限等级是否达到api要求

                    * 关于用户权限的确定也可以现在数据库中预先生成，在登录时获取用户权限等级，然后交由全局对象保存，利用全局对象的权限做判断
                      global or koa2 ctx对象
            
            4. 接口签名：
                签名的意义：
                    签名的意义是对服务端接口进行保护，防止非法访问，和ddos攻击（分布式拒绝服务。
                    一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务）
                    
                    签名的一般做法：
                        客户端对提交的参数，时间戳，公钥进行加密处理，生成签名。接口的提供方按照密钥，验签

        

    
    js:
        class：
            1. constructor() : 相当于构造函数
            2. 类中定义的方法会被new实例继承
            3. static 静态方法不会被new实例继承，static的使用可以直接通过class调用
            4. static 方法中调用this，执向类本身，而不是实例
            5. new实例不能调用静态方法
            6. 类中直接定义的方法归为‘实例方法’

        object：
            1. 对象的解构赋值: 解构之后可以直接在页面上使用
                let { a, b, c } = require('xxx').obj


        * 如果自己封装一个校验参数工具的思路
            校验流程：传参（考虑到参数获取方式的不同）
                      自己校验 or 结合第三方库校验
                      把校验结果传递给异常处理类 - 



    服务端编程的外延：
        1. 项目部署
        2. 网站安全
        3. 网站并发处理

 -->
