<!-- 
    服务端编程：
        * 项目启动 node app.js
        1. 确定项目架构，目录结构
        2. 基础的项目构成：
            1. 接口api
            2. 参数解析，校验，正确响应客户端
            3. 异常处理api
        
        3. 区分koa@/router 和 koa-router

        4. 中间件: koa2 面相中间件编程，每一个方法都是一个中间件（中间件声明后可以交给全局对象注册！）

        5. V2版本：
                使用 lin-validator 检验路由参数

                取参方式：
                    v.get("query.id")   url ?参数
                    v.get("path.id")    请求路径
                    v.get("body.id")    json 参数

    项目结构目录规划：
        1. api: 存放各个版本的接口，每个版本分为不同的文件夹
            1. v1 v2（ Version ）编写具体的接口文件
               路由自动注册

            2. models：数据库操作模型
                * 每一个模型（model）负责一个数据库表的操作，包括表名，初始化字段，以及对表数据的基本操作（增删改查）
                * 暂时规定数据库操作都放在model模型类下

        
        2. core: 非业务代码，初始化，数据库连接等模块
            db.js: 数据库连接模块

        3. validators: 参数校验类
        4. middlewares: 全局异常捕获中间件
        5. config：项目的配置文件
        6. modals：数据库操作模块


        疑问：
            1. require() 导入的模块可以任意赋值？
                module.export = router
                const a = require('book.js')

            2. 引用lin-validator
                为什么有些地方还要throw new error      


        数据库编程经验：
            注册接口：
                1. 注册接口要保障主键的唯一性，在注册前需要查询库数据是否已存在
                2. 注册的核心数据要以密文的方式存储，比如密码...

                注册接口常规方式：
                    1. 注册信息提交
                    2. 校验路由参数的合法性
                    3. 校验读取数据库校验账号信息的唯一性
                    4. 对需要加密的字段进行存储加密，为账号分配主键id
                    5. 最后入口返回客户端成功的信息

                    * 在这个过程中如果发生异常也需要把异常抛出，定义明确的错误码，和错误信息

            加密库：
                bcrypt.js
        
        服务端接口：
            1. 登录接口
                登录接口常规方式：
                        登录的两种状态：
                            一首次登录，需要提供账号密码验证身份，返回token
                            二利用token做无痕登录，验证token的有效性，有效则直接登录，无效则重新拉起账号登录
                    1. 客户端登录提交登录信息和登录方式到服务接口
                    2. 验证路由参数的合法性
                    3. 向数据库查询账号，密码的有效性
                    4. 查询成功后需要根据用户的身份信息生成登录身份令牌（token）返回给客户端

                    * 在登录的过程中注意登录身份的有效性，token的时效，给客户端明确的返回信息

                登陆令牌：token
                访问令牌：Access token
                密保令牌：Security token
                会话令牌：Session token
                    1. 令牌含义：
                        在OAuth协议中，token是在输入了用户名和密码之后获取的，利用这个token你可以拥有查看或者操作相应的资源的权限。你有这些权限，是因为服务器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。
                        器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。
                    
                    2. 生成：
                        1. 用户登录后后端根据用户信息生成一个唯一的凭证，这个就是token值
                    
                    3. 使用：
                        客服端获取服务端的token后保存在本地中，作为用户已登录的依据，访问时验证token的有效性，从而无需用户重复登录
                        可以保存在用户的cookie localStorage

                    4. token的有效性：
                        资讯型网站用户数据不是太敏感，token可以较长。银行类，支付类网站token时效性较短

                    5. 唯一性：
                        当用户重新登录或者token已过时需要重新获取令牌

            2. 用户权限管理：
                权限的意义：
                    对登录的用户做开放权力的区分对待：超级管理员，管理员，会员，普通用户，游客等身份象征，不同的角色会开放不同的权限。
                    和接口的权限做对应关系
                做法1：
                    1. 利用token的scope对用户做权限分级
                    2. 在用户登录的的时候根据登录方式确定权限等级，在登录合法后为用户分配token。同时给token的scope分配权限
                    3. 在用户访问api时校验参数，校验api的权限等级，把参数中token.scope.auth等级和api所需要的auth等级做对比
                    4. 最后做出判断，用户的权限等级是否达到api要求

                    * 关于用户权限的确定也可以现在数据库中预先生成，在登录时获取用户权限等级，然后交由全局对象保存，利用全局对象的权限做判断
                      global or koa2 ctx对象
            
            3. 接口签名：
                签名的意义：
                    签名的意义是对服务端接口进行保护，防止非法访问，和ddos攻击（分布式拒绝服务。
                    一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务）
                    
                    签名的一般做法：
                        客户端对提交的参数，时间戳，公钥进行加密处理，生成签名。接口的提供方按照密钥，验签

            4. 接口参数的传递：UID：user_id
                1. 普通参数 : 直接通过接口在request中传递
                2. 用户身份 : 身份参数如果以接口的方式传递，可能存在身份暴露，或者出现接口被非法调用，冒充身份，盗取其他用户身份信息的情况
                3. node-koa : 是通过head base-auth 传递token，服务端解密获取uid, 然后存储在服务端的ctx全局上下文中。在需要的接口中直接获取
                              ctx.auth.u_id？


        服务端编程小技巧：
            1. 别名系统：简化文件引入，缩短路径编写：node：module-alias 
                        app.js  require('module-alias/register')

            2. node传参的区别：body传参会自动转为Number类型，url则为字符串类型

            3. 前端缓存和后端缓存：缓存的实现有利于提高页面性能，减少服务器压力
                * 可以前端缓存的尽量前端做，性能提升更高，因为可以彻底不用做http请求。但是要求的动态数据就必须请求后端
                * 后台数据后端同样可以实现缓存，常用的有Redis

            db方面：
                1. scope：作用域空间，预置sql条件，在需要使用的model实例上操作数据表，传入对应的scope名，即可调用
                    以及scope在做update时出现SQL bug (原来的版本，现在未知)

                2. db查找数据集合：传入条件，做in查询，数据库可以一次性查找出所有符合条件的数据

                3. db使用group条件对查询的数据做聚合，根据选取的键名对一组数据做聚合操作，并且可以做统计计数

                4. 本身不具有排序属性的数据要实现hot,需要给记录加上index字段，利用index排序，从而实现hot商品


        js编程知识：
            1. 遍历：for in or for of 的区别：
                1. for in 遍历对象键值
                2. for of 遍历数组，不需要i做index

            2. JavaScript的object的key为字符串类型，所以当做参数传递的时候要注意type是否满足

            3. 函数和类的区别：
                1. 函数更具有功能特性，为了实现某个具体的功能而实现的方法，它没有类的扩展性，继承性等
                2. 类是描述一种事务的抽象，他可以包含更多的私有，共有方法，具有可扩展性，继承性等特点

            4. 
        

    
    js:
        class：
            1. constructor() : 相当于构造函数
            2. 类中定义的方法会被new实例继承
            3. static 静态方法不会被new实例继承，static的使用可以直接通过class调用
            4. static 方法中调用this，执向类本身，而不是实例
            5. new实例不能调用静态方法
            6. 类中直接定义的方法归为‘实例方法’

        object：
            1. 对象的解构赋值: 解构之后可以直接在页面上使用
                let { a, b, c } = require('xxx').obj


        * 如果自己封装一个校验参数工具的思路
            校验流程：传参（考虑到参数获取方式的不同）
                      自己校验 or 结合第三方库校验
                      把校验结果传递给异常处理类 - 



    服务端编程的外延：
        1. 项目部署
        2. 网站安全
        3. 网站并发处理

 -->
