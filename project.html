<!-- 
    服务端编程：
        * 项目启动 node app.js
        1. 确定项目架构，目录结构
        2. 基础的项目构成：
            1. 接口api
            2. 参数解析，校验，正确响应客户端
            3. 异常处理api
        
        3. 区分koa@/router 和 koa-router

        4. 中间件: koa2 面相中间件编程，每一个方法都是一个中间件（中间件声明后可以交给全局对象注册！）

        5. V2版本：
                使用 lin-validator 检验路由参数

                取参方式：
                    v.get("query.id")   url ?参数
                    v.get("path.id")    请求路径
                    v.get("body.id")    json 参数

    项目结构目录规划：
        1. api: 存放各个版本的接口，每个版本分为不同的文件夹
            1. v1 v2（ Version ）编写具体的接口文件
               路由自动注册

            2. models：数据库操作模型
                每一个模型（model）负责一个数据库表的操作，包括表名，初始化字段，以及对表数据的基本操作（增删改查）

        
        2. core: 非业务代码，初始化，数据库连接等模块
            db.js: 数据库连接模块

        3. validators: 参数校验类
        4. middlewares: 全局异常捕获中间件
        5. config：项目的配置文件
        6. modals：数据库操作模块

        疑问：
            1. require() 导入的模块可以任意赋值？
                module.export = router
                const a = require('book.js')

            2. 引用lin-validator
                为什么有些地方还要throw new error      


        数据库编程经验：
            注册接口：
                1. 注册接口要保障主键的唯一性，在注册前需要查询库数据是否已存在
                2. 注册的核心数据要以密文的方式存储，比如密码...

                注册接口常规方式：
                    1. 注册信息提交
                    2. 校验路由参数的合法性
                    3. 校验读取数据库校验账号信息的唯一性
                    4. 对需要加密的字段进行存储加密，为账号分配主键id
                    5. 最后入口返回客户端成功的信息

                    * 在这个过程中如果发生异常也需要把异常抛出，定义明确的错误码，和错误信息

            加密库：
                bcrypt.js
        
        服务端接口：
            1. 登录接口
                登录接口常规方式：
                        登录的两种状态：
                            一首次登录，需要提供账号密码验证身份，返回token
                            二利用token做无痕登录，验证token的有效性，有效则直接登录，无效则重新拉起账号登录
                    1. 客户端登录提交登录信息和登录方式到服务接口
                    2. 验证路由参数的合法性
                    3. 向数据库查询账号，密码的有效性
                    4. 查询成功后需要根据用户的身份信息生成登录身份令牌（token）返回给客户端

                    * 在登录的过程中注意登录身份的有效性，token的时效，给客户端明确的返回信息

                登陆令牌：token
                访问令牌：Access token
                密保令牌：Security token
                会话令牌：Session token
                    1. 令牌含义：
                        在OAuth协议中，token是在输入了用户名和密码之后获取的，利用这个token你可以拥有查看或者操作相应的资源的权限。你有这些权限，是因为服务器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。
                        器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。
                    
                    2. 生成：
                        1. 用户登录后后端根据用户信息生成一个唯一的凭证，这个就是token值
                    
                    3. 使用：
                        客服端获取服务端的token后保存在本地中，作为用户已登录的依据，访问时验证token的有效性，从而无需用户重复登录
                        可以保存在用户的cookie localStorage

                    4. token的有效性：
                        资讯型网站用户数据不是太敏感，token可以较长。银行类，支付类网站token时效性较短

                    5. 唯一性：
                        当用户重新登录或者token已过时需要重新获取令牌

            2. 用户权限管理：
                权限的意义：
                    对登录的用户做开放权力的区分对待：超级管理员，管理员，会员，普通用户，游客等身份象征，不同的角色会开放不同的权限。
                    和接口的权限做对应关系
                做法1：
                    1. 利用token的scope对用户做权限分级
                    2. 在用户登录的的时候根据登录方式确定权限等级，在登录合法后为用户分配token。同时给token的scope分配权限
                    3. 在用户访问api时校验参数，校验api的权限等级，把参数中token.scope.auth等级和api所需要的auth等级做对比
                    4. 最后做出判断，用户的权限等级是否达到api要求

                    * 关于用户权限的确定也可以现在数据库中预先生成，在登录时获取用户权限等级，然后交由全局对象保存，利用全局对象的权限做判断
                      global or koa2 ctx对象
            
            3. 接口签名：
                签名的意义：
                    签名的意义是对服务端接口进行保护，防止非法访问，和ddos攻击（分布式拒绝服务。
                    一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务）
                    
                    签名的一般做法：
                        客户端对提交的参数，时间戳，公钥进行加密处理，生成签名。接口的提供方按照密钥，验签

            4. 接口参数的传递：UID：user_id
                1. 普通参数 : 直接通过接口在request中传递
                2. 用户身份 : 身份参数如果以接口的方式传递，可能存在身份暴露，或者出现接口被非法调用，冒充身份，盗取其他用户身份信息的情况
                3. node-koa : 是通过head base-auth 传递token，服务端解密获取uid, 然后存储在服务端的ctx全局上下文中。在需要的接口中直接获取
                              ctx.auth.u_id

                * 对于把用户身份通过token解密，存储在ctx上下文中，是如何区分不同的用户的？！！
                * 对于web而已，是把获取的数据以客户端为载体，存在在不同的设备平台中，而服务器就一台，或者几台，是如何区分不同用户对象的？



        服务端编程小技巧：model module alias favor 
            1. 别名系统：简化文件引入，缩短路径编写：node：module-alias 


        

    
    js:
        class：
            1. constructor() : 相当于构造函数
            2. 类中定义的方法会被new实例继承
            3. static 静态方法不会被new实例继承，static的使用可以直接通过class调用
            4. static 方法中调用this，执向类本身，而不是实例
            5. new实例不能调用静态方法
            6. 类中直接定义的方法归为‘实例方法’

        object：
            1. 对象的解构赋值: 解构之后可以直接在页面上使用
                let { a, b, c } = require('xxx').obj


        * 如果自己封装一个校验参数工具的思路
            校验流程：传参（考虑到参数获取方式的不同）
                      自己校验 or 结合第三方库校验
                      把校验结果传递给异常处理类 - 



    服务端编程的外延：
        1. 项目部署
        2. 网站安全
        3. 网站并发处理

 -->
